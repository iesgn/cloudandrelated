---
layout: presentacion
title: docker
tema: white
---
<section>
  <h2>docker</h2>
  <p><strong>"Build, Ship and Run. Any application, Anywhere"</strong></p>
  <p>
    Alberto Molina Coballes, José Luis Rodríguez Rodríguez and José Domingo Muñoz Rodríguez
  </p>
  <p><small>Cloud Computing in European schools. Project: 2017-1-ES01-KA202-038471</small></p>
  <p><img src="img/UE.png" width="250px" border="0"/>
    <img src="img/iesvalleinclan.png" width="250px" border="0"/>
  </p>
  <p>
    <a href="http://creativecommons.org/licenses/by-sa/3.0/">
      <img src="img/cc_by_sa.png" width="100px" border="0"/></a>
  </p>
  <p><small>Theme by: <a href="http://lab.hakim.se/reveal-js/#/">reveal.js</a></small></p>
</section>

<section>
  <h3>Docker</h3>
  <ul>
    <li>Lightweight virtualization: we make better use of the hardware
    and only need the minimum file system for the services to
      work.</li>
    <li>Containers are self-sufficient, we only need one image to
      create containers.</li>
    <li>A Docker image can be understood as "an Operating System with
      installed applications".</li>
    <li>The project offers us a repository of images: Registry Docker
      Hub that allows us to manage images.</li>
    <li>A container usually runs only one service. An application
    usually needs the execution of several containers that work
      together.</li>
  </ul>
</section>
<section>
  <h3>Docker main components</h3>
  <ul>
    <li><strong>Docker Engine</strong>: It is a daemon that runs on any
    Linux distribution and that exposes an external API for the
    management of images and containers.</li>
    <li><strong>Docker Client</strong>: It is the command line client
    (CLI) that allows us to manage the Docker Engine. The docker
    client can be configured to work with a local or remote Docker
    Engine.</li>
    <li><strong>Docker Registry</strong>: The purpose of this
    component is to store the images generated by the Docker
    Engine. It allows us to distribute our images. We can install a
    private registry, or make use of a public one such as Docker
    Hub.</li>
  </ul>
</section>

<section>
  <h2>The life cycle of docker based applications</li>
</section>
<section>
  <h4>Step 1: Development of the application</h4>
  <p>In this example we are going to develop a web page that will be
  served by a web server that will run in a Docker container.</p>
  <p>So the first thing we need to do is create our web page:</p>
  <pre><code data-trim data-noescape>
  $ cd public_html
  echo "&lt;h1&gt;Prueba&lt;/h1&gt;" > index.html
  </code></pre>
</section>
<section>
<section>
  <h4>Step 2: Creating the Docker image</h4>
  <p>Using a Dockerfile we define how we are going to create our
    image:</p>
  <ul>
    <li>Which base image we are going to use.</li>
    <li>Which packages we are going to install</li>
    <li>Where we copy our source code (web page)</li>
    <li>We indicate the service that will run the container (apache
      server)</li>
  </ul>
</section>
<section>
  <h4>Step 2: Creating the Docker image</h4>
  <p><code>Dockerfile</code></p>
  <pre><code>
    FROM debian
    RUN apt-get update -y && apt-get install -y \
        apache2 \
        && apt-get clean && rm -rf /var/lib/apt/lists/*
    COPY ./public_html /var/www/html/
    ENTRYPOINT ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]
  </code></pre>
  <p>We can also choose a base image with apache included:</p>
  <pre><code>
    FROM httpd:2.4
    COPY ./public_html /usr/local/apache2/htdocs/
  </code></pre>
</section>
<section>
  <h4>Step 2: Creating the Docker image</h4>
  <p>To create the image, from the directory where <code>Dockerfile</code> is located, execute:</p>
  <pre><code>
    $ docker build -t josedom24/aplicacionweb:v1 .
    Sending build context to Docker daemon  3.584kB
    Step 1/4 : FROM debian
     ---> be2868bebaba
    Step 2/4 : RUN apt-get update -y && apt-get install -y apache2 & apt-get clean && rm -rf /var/lib/apt/lists/*
     ...
    Successfully built 518871c9fc0c
    Successfully tagged josedom24/aplicacionweb:v1
  </code></pre>
</section>
<section>
  <h4>Step 2: Creating the Docker image</h4>
  <p>We can verify that the new image is available:</p>
  <pre><code>
    $ docker image ls
    REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE
    josedom24/aplicacionweb   v1                  b2e0df215145        7 seconds ago       204MB
    debian                    latest              be2868bebaba        10 days ago         101MB
  </code></pre>
</section>
</section>
<section>
<section>
  <h4>Step 3: Using the application in a development environment</h4>
  <p>We just need to run the container with the application:</p>
  <pre><code>
  $ docker run --name aplweb -d -p 80:80 josedom24/aplicacionweb:v1
  fbdd73529e2bb2d9ee9c6415031513741688e6d38509572251f5b624ed7dc23f
  
  $ docker container ls
  CONTAINER ID        IMAGE                        COMMAND                    CREATED             STATUS              PORTS                NAMES
  fbdd73529e2b        josedom24/aplicacionweb:v1   "/usr/sbin/apache2ct…"   6 seconds ago       Up 5 seconds        0.0.0.0:80->80/tcp   aplweb
  </code></pre>
</section>
<section>
  <h4>Step 3: Using the application in a development environment</h4>
  <p>And now, we can check the application is available:</p>
  <img src="img/docker1.png"/>
</section>
</section>
<section>
  <h4>Step 4: Sharing the image</h4>
  <p>Docker hub or any other docker registry can be used to upload the
  image and share it with others</p>
  <pre><code>
    $ docker login
    ...
    $ docker push josedom24/aplicacionweb:v1
    The push refers to repository [docker.io/josedom24/aplicacionweb]
    ac126159496f: Pushed 
    cc15ec5f0c43: Pushed 
    ...
  </code></pre>
  <p>Comprobamos que está subida al repositorio:</p>
  <pre><code>
    $ docker search josedom24/aplicacionweb
    NAME                     DESCRIPTION...
    josedom24/aplicacionweb:v1   
  </code></pre>
</section>
<section>
  <h5>Step 5: Deploying the application</h5>
  <p>From the <strong>production environment</strong> the image can be
  downloaded and a new container launched:</p>
  <pre><code>
    $ docker pull josedom24/aplicacionweb:v1
    v1: Pulling from josedom24/aplicacionweb
    9a029d5ca5bb: Pull complete 
    ...
    $ docker run --name aplweb_prod -d -p 80:80 josedom24/aplicacionweb:v1
  </code></pre>
</section>
<section>
<section>
  <h4>Step 6: Modifying the application</h4>
  <p>If the code is modified, a new image must be created.</p>
  <pre><code>
    $ cd public_html
    echo "&lt;h1&gt;Prueba 2&lt;/h1&gt;" > index.html
    $ docker build -t josedom24/aplicacionweb:v2 .
    </code></pre>
  <p>The new image must be tested in the development environment, so
  the previous release can be deleted:</p>
  <pre><code>
    $ doker container rm -f aplweb
    $ docker run --name aplweb2 -d -p 80:80 josedom24/aplicacionweb:v2
  </code></pre>
  <img src="img/docker2.png"/>
</section>
<section>
  <h4>Step 6: Modifying the application</h4>
  <p>The new release is downloaded from the production environment,
  removing the previous release and launching a container based on the
  new image:</p>
  <pre><code>
    $ docker push josedom24/aplicacionweb:v1
    ...
  </code></pre>
  <p>En producción:</p>
  <pre><code>
    $ docker pull josedom24/aplicacionweb:v2
    ...
    $ doker container rm -f aplweb_prod
    $ docker run --name aplweb2_prod -d -p 80:80 josedom24/aplicacionweb:v2
  </code></pre>
</section>
</section>
<section>
<section>
  <h2>Stateless vs statefull</h2>
  <ul>
    <li>A stateless application doesn't store any information about
    a previous session in the server, so any session is a
    complete new session from the server side</li>
    <li>A stateful application stores information about any session in
    the server, so following sessions depends on the information
    stored.</li>
    <li>Stateless applications are preferred when using containers,
    many new applications claim to be stateless today</li>
    <li>Traditional applications use to be stateful, so they're not
    suitable to be run inside containers</li>
  </ul>
</section>
<section>
  <h2>Persistent volumes</h2>
  <ul>
    <li>Data stored in a container is not persistent.</li>
    <li>When data must be stored persistently, volumes must be used.</li>
  </ul>
</section>
<section>
  <h2>Persistent volumes</h2>
  <ul>
    <li>Containers are lightweight</li>
    <li>Data not stored in the image</li>
    <li>When a container fails, the data is not lost. A new container
    can be created to use it</li>
  </ul>
</section>
<section>
  <h4>Example: Persistent storage</h4>
  <p>Conatiner with a database, the data is stored in a persistent volume:</p>
  <pre><code>
    $ docker run --name some-mysql \ 
                 -v /opt/mysql:/var/lib/mysql \
                 -e MYSQL_ROOT_PASSWORD=asdasd \
                 -d mysql
  </code></pre>
  <small>Let's check the data have been stored:</small>
  <pre><code>
    /opt/mysql$ ls
    ibdata1  ib_logfile0  ib_logfile1  ibtmp1  #innodb_temp  mysql  mysql.ibd  undo_001  undo_002
  </code></pre>
</section>
<section>
  <h4>Example: Persistent storage</h4>
  <small>A new databse is created:</small>
  <pre><code>
  $ docker exec -it some-mysql bash
  root@75544a024f9b:/# mysql -u root -p -h localhost
  ...
  create database dbtest;
  Query OK, 1 row affected (0.07 sec)
  </code></pre>
<small>Suddenly the container fails! and it must be deleted</small>
<pre><code>
  $ docker container rm -f some-mysql 
</code></pre>
</section>
<section>
  <h4>Example: Persistent storage</h4>
  <small>A new container can be created using the same persistent
  volume and any all the data is available again:</small>
  <pre><code>
    $ docker run --name some-mysql2 \
                -v /opt/mysql:/var/lib/mysql \
                -e MYSQL_ROOT_PASSWORD=asdasd \
                -d mysql
    
    $ docker exec -it some-mysql2 bash
    root@878f77d80fcf:/# mysql -u root -p -h localhost
    ...
    show databases;
    ...
    | dbtest             |
    ...
  </code></pre>
</section>
</section>

